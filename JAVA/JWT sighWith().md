# JWT signWith()

signWith()는 어떤 알고리즘과 키값으로 인코딩+해싱할지 설정하는 메소드다
구버전 JJWT 라이브러리 (0.9.x 이하)은 알고리즘은 반드시 명시해야 했고
0.9버전 이상부터는 알고리즘 자동 추론 기능이 추가되었다.

그럼 명시적으로 알고리즘을 저장할 필요가 없는거 아니야? 라는 의문이 들 수 있는데
명시적으로 설정하는 것이 좋다

JJWT 라이브러리는 secretKey 길이(바이트 크기)에 따라 알고리즘을 자동으로 선택한다

그래서 일반적으로는 문제가 발생하지 않는게 맞다
하지만 개발자는 예기치 못한 버그도 미리 방지해야 한다

1. 환경별로 다른 알고리즘을 사용하는 경우
```yaml
# 개발 환경 (application-dev.yml)
jwt:
  secret-key: "mySecretKey123456789012345678"  # 32바이트 → HS256

# 운영 환경 (application-prod.yml)  
jwt:
  secret-key: "myVeryLongProductionSecretKey123456789012345678901234567890123456"  # 64바이트 → HS512
```

개발환경과 운영환경이 서로 다르다고 가정한 다음
```java
// 개발환경에서 생성된 토큰
String devToken = createToken(); // HS256으로 서명됨

// 운영환경에 배포 후
boolean isValid = validateToken(devToken); // HS512로 검증 시도 → 실패!
```
앞서 키의 길이에 따라 알고리즘을 자동으로 선택한다고 하였다
개발환경과 운영환경의 시크릿 키가 서로 달라 다른 알고리즘을 자동으로 선택하였고 검증에 실패하였다

2. MSA에서 토큰 불일치
서비스별로 다른 토큰이 설정되어 다른 알고리즘이 자동으로 선택되는 경우도 있을 것이다